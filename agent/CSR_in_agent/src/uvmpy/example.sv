//==============================================================================//
// File       : example.sv
// Author     : automatically generated by picker
// Date       : 2026-02-03 12:11:13
// Description: UVM testbench for CSR_in_agent_xaction example
//              Supports bidirectional communication (Python ←→ UVM)
//              - Driver receives transactions from Python and drives DUT
//              - Monitor samples DUT outputs and sends back to Python
// Version    : v0.1
//==============================================================================//
import uvm_pkg::*;
import uvmc_pkg::*;

// Include common utility package before agents
`include "CSR_in_agent_xaction/utils_pkg.sv"

// include transaction definitions and agents
`include "CSR_in_agent_xaction.sv"
`include "CSR_in_agent_xaction/xagent.sv"
// Interface for DUT signals (auto-generated from transactions)
interface dut_interface(input clk, input rst_n);
logic io_csr_intrBitSet;
logic io_csr_wfiEvent;
logic io_csr_criticalErrorState;
logic io_snpt_snptDeq;
logic io_snpt_useSnpt;
logic [1:0] io_snpt_snptSelect;
logic io_snpt_flushVec_0;
logic io_snpt_flushVec_1;
logic io_snpt_flushVec_2;
logic io_snpt_flushVec_3;
logic io_wfi_safeFromMem;
logic io_wfi_safeFromFrontend;
logic io_wfi_enable;
logic io_fromVecExcpMod_busy;
logic [55:0] io_readGPAMemData_gpaddr;
logic io_readGPAMemData_isForVSnonLeafPTE;
logic io_vstartIsZero;
logic io_debugEnqLsq_canAccept;
logic [1:0] io_debugEnqLsq_needAlloc_0;
logic [1:0] io_debugEnqLsq_needAlloc_1;
logic [1:0] io_debugEnqLsq_needAlloc_2;
logic [1:0] io_debugEnqLsq_needAlloc_3;
logic [1:0] io_debugEnqLsq_needAlloc_4;
logic [1:0] io_debugEnqLsq_needAlloc_5;
logic io_debugEnqLsq_req_0_valid;
logic [7:0] io_debugEnqLsq_req_0_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_0_bits_lqIdx_value;
logic io_debugEnqLsq_req_1_valid;
logic [7:0] io_debugEnqLsq_req_1_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_1_bits_lqIdx_value;
logic io_debugEnqLsq_req_2_valid;
logic [7:0] io_debugEnqLsq_req_2_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_2_bits_lqIdx_value;
logic io_debugEnqLsq_req_3_valid;
logic [7:0] io_debugEnqLsq_req_3_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_3_bits_lqIdx_value;
logic io_debugEnqLsq_req_4_valid;
logic [7:0] io_debugEnqLsq_req_4_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_4_bits_lqIdx_value;
logic io_debugEnqLsq_req_5_valid;
logic [7:0] io_debugEnqLsq_req_5_bits_robIdx_value;
logic [6:0] io_debugEnqLsq_req_5_bits_lqIdx_value;
logic io_debugInstrAddrTransType_bare;
logic io_debugInstrAddrTransType_sv39;
logic io_debugInstrAddrTransType_sv39x4;
logic io_debugInstrAddrTransType_sv48;
logic io_debugInstrAddrTransType_sv48x4;
logic [7:0] io_storeDebugInfo_0_robidx_value;
logic [7:0] io_storeDebugInfo_1_robidx_value;
logic compare;
logic CSR_in_agent_xaction;
logic super_result;
endinterface
// =============================================================================
// DUT Mode: UVM-compliant Driver and Monitor
// =============================================================================

// Driver for CSR_in_agent_xaction - receives from Python and drives DUT inputs
class CSR_in_agent_xaction_driver extends CSR_in_agent_xaction_xdriver;
    `uvm_component_utils(CSR_in_agent_xaction_driver);

    virtual dut_interface vif;
    int transaction_count;

    function new (string name = "CSR_in_agent_xaction_driver", uvm_component parent = null);
        super.new(name, parent);
        transaction_count = 0;
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("CSR_in_agent_xaction_driver", "Virtual interface not found")
    endfunction

    virtual task sequence_receive(CSR_in_agent_xaction tr);
        transaction_count++;
        `uvm_info("CSR_in_agent_xaction_driver",
                  $sformatf("Received transaction #%0d from Python:\n%s", transaction_count, tr.sprint()),
                  UVM_LOW)

        // Drive DUT inputs through VIF
vif.io_csr_intrBitSet = tr.io_csr_intrBitSet;
vif.io_csr_wfiEvent = tr.io_csr_wfiEvent;
vif.io_csr_criticalErrorState = tr.io_csr_criticalErrorState;
vif.io_snpt_snptDeq = tr.io_snpt_snptDeq;
vif.io_snpt_useSnpt = tr.io_snpt_useSnpt;
vif.io_snpt_snptSelect = tr.io_snpt_snptSelect;
vif.io_snpt_flushVec_0 = tr.io_snpt_flushVec_0;
vif.io_snpt_flushVec_1 = tr.io_snpt_flushVec_1;
vif.io_snpt_flushVec_2 = tr.io_snpt_flushVec_2;
vif.io_snpt_flushVec_3 = tr.io_snpt_flushVec_3;
vif.io_wfi_safeFromMem = tr.io_wfi_safeFromMem;
vif.io_wfi_safeFromFrontend = tr.io_wfi_safeFromFrontend;
vif.io_wfi_enable = tr.io_wfi_enable;
vif.io_fromVecExcpMod_busy = tr.io_fromVecExcpMod_busy;
vif.io_readGPAMemData_gpaddr = tr.io_readGPAMemData_gpaddr;
vif.io_readGPAMemData_isForVSnonLeafPTE = tr.io_readGPAMemData_isForVSnonLeafPTE;
vif.io_vstartIsZero = tr.io_vstartIsZero;
vif.io_debugEnqLsq_canAccept = tr.io_debugEnqLsq_canAccept;
vif.io_debugEnqLsq_needAlloc_0 = tr.io_debugEnqLsq_needAlloc_0;
vif.io_debugEnqLsq_needAlloc_1 = tr.io_debugEnqLsq_needAlloc_1;
vif.io_debugEnqLsq_needAlloc_2 = tr.io_debugEnqLsq_needAlloc_2;
vif.io_debugEnqLsq_needAlloc_3 = tr.io_debugEnqLsq_needAlloc_3;
vif.io_debugEnqLsq_needAlloc_4 = tr.io_debugEnqLsq_needAlloc_4;
vif.io_debugEnqLsq_needAlloc_5 = tr.io_debugEnqLsq_needAlloc_5;
vif.io_debugEnqLsq_req_0_valid = tr.io_debugEnqLsq_req_0_valid;
vif.io_debugEnqLsq_req_0_bits_robIdx_value = tr.io_debugEnqLsq_req_0_bits_robIdx_value;
vif.io_debugEnqLsq_req_0_bits_lqIdx_value = tr.io_debugEnqLsq_req_0_bits_lqIdx_value;
vif.io_debugEnqLsq_req_1_valid = tr.io_debugEnqLsq_req_1_valid;
vif.io_debugEnqLsq_req_1_bits_robIdx_value = tr.io_debugEnqLsq_req_1_bits_robIdx_value;
vif.io_debugEnqLsq_req_1_bits_lqIdx_value = tr.io_debugEnqLsq_req_1_bits_lqIdx_value;
vif.io_debugEnqLsq_req_2_valid = tr.io_debugEnqLsq_req_2_valid;
vif.io_debugEnqLsq_req_2_bits_robIdx_value = tr.io_debugEnqLsq_req_2_bits_robIdx_value;
vif.io_debugEnqLsq_req_2_bits_lqIdx_value = tr.io_debugEnqLsq_req_2_bits_lqIdx_value;
vif.io_debugEnqLsq_req_3_valid = tr.io_debugEnqLsq_req_3_valid;
vif.io_debugEnqLsq_req_3_bits_robIdx_value = tr.io_debugEnqLsq_req_3_bits_robIdx_value;
vif.io_debugEnqLsq_req_3_bits_lqIdx_value = tr.io_debugEnqLsq_req_3_bits_lqIdx_value;
vif.io_debugEnqLsq_req_4_valid = tr.io_debugEnqLsq_req_4_valid;
vif.io_debugEnqLsq_req_4_bits_robIdx_value = tr.io_debugEnqLsq_req_4_bits_robIdx_value;
vif.io_debugEnqLsq_req_4_bits_lqIdx_value = tr.io_debugEnqLsq_req_4_bits_lqIdx_value;
vif.io_debugEnqLsq_req_5_valid = tr.io_debugEnqLsq_req_5_valid;
vif.io_debugEnqLsq_req_5_bits_robIdx_value = tr.io_debugEnqLsq_req_5_bits_robIdx_value;
vif.io_debugEnqLsq_req_5_bits_lqIdx_value = tr.io_debugEnqLsq_req_5_bits_lqIdx_value;
vif.io_debugInstrAddrTransType_bare = tr.io_debugInstrAddrTransType_bare;
vif.io_debugInstrAddrTransType_sv39 = tr.io_debugInstrAddrTransType_sv39;
vif.io_debugInstrAddrTransType_sv39x4 = tr.io_debugInstrAddrTransType_sv39x4;
vif.io_debugInstrAddrTransType_sv48 = tr.io_debugInstrAddrTransType_sv48;
vif.io_debugInstrAddrTransType_sv48x4 = tr.io_debugInstrAddrTransType_sv48x4;
vif.io_storeDebugInfo_0_robidx_value = tr.io_storeDebugInfo_0_robidx_value;
vif.io_storeDebugInfo_1_robidx_value = tr.io_storeDebugInfo_1_robidx_value;
vif.compare = tr.compare;
vif.CSR_in_agent_xaction = tr.CSR_in_agent_xaction;
vif.super_result = tr.super_result;
<<<<<<< HEAD

=======
>>>>>>> feat_uvm
        `uvm_info("CSR_in_agent_xaction_driver", "DUT inputs driven", UVM_MEDIUM)
    endtask

    function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        `uvm_info("CSR_in_agent_xaction_driver",
                  $sformatf("Total transactions received: %0d", transaction_count),
                  UVM_LOW)
    endfunction
endclass

// Monitor for CSR_in_agent_xaction - independently samples DUT outputs
class CSR_in_agent_xaction_monitor extends CSR_in_agent_xaction_xmonitor;
    `uvm_component_utils(CSR_in_agent_xaction_monitor);

    virtual dut_interface vif;
    CSR_in_agent_xaction prev_tr;

    function new (string name = "CSR_in_agent_xaction_monitor", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("CSR_in_agent_xaction_monitor", "Virtual interface not found")
        prev_tr = CSR_in_agent_xaction::type_id::create("prev_tr");
    endfunction

    virtual task run_phase(uvm_phase phase);
        CSR_in_agent_xaction tr;

        forever begin
            // Default: Sequential logic sampling (clock edge)
            @(posedge vif.clk);

            // Uncomment for combinational logic sampling:
            // @(vif signal changes);
            // #1step;  // Wait for combinational logic to settle

            // Sample all signals from VIF
            tr = CSR_in_agent_xaction::type_id::create("tr");
tr.io_csr_intrBitSet = vif.io_csr_intrBitSet;
tr.io_csr_wfiEvent = vif.io_csr_wfiEvent;
tr.io_csr_criticalErrorState = vif.io_csr_criticalErrorState;
tr.io_snpt_snptDeq = vif.io_snpt_snptDeq;
tr.io_snpt_useSnpt = vif.io_snpt_useSnpt;
tr.io_snpt_snptSelect = vif.io_snpt_snptSelect;
tr.io_snpt_flushVec_0 = vif.io_snpt_flushVec_0;
tr.io_snpt_flushVec_1 = vif.io_snpt_flushVec_1;
tr.io_snpt_flushVec_2 = vif.io_snpt_flushVec_2;
tr.io_snpt_flushVec_3 = vif.io_snpt_flushVec_3;
tr.io_wfi_safeFromMem = vif.io_wfi_safeFromMem;
tr.io_wfi_safeFromFrontend = vif.io_wfi_safeFromFrontend;
tr.io_wfi_enable = vif.io_wfi_enable;
tr.io_fromVecExcpMod_busy = vif.io_fromVecExcpMod_busy;
tr.io_readGPAMemData_gpaddr = vif.io_readGPAMemData_gpaddr;
tr.io_readGPAMemData_isForVSnonLeafPTE = vif.io_readGPAMemData_isForVSnonLeafPTE;
tr.io_vstartIsZero = vif.io_vstartIsZero;
tr.io_debugEnqLsq_canAccept = vif.io_debugEnqLsq_canAccept;
tr.io_debugEnqLsq_needAlloc_0 = vif.io_debugEnqLsq_needAlloc_0;
tr.io_debugEnqLsq_needAlloc_1 = vif.io_debugEnqLsq_needAlloc_1;
tr.io_debugEnqLsq_needAlloc_2 = vif.io_debugEnqLsq_needAlloc_2;
tr.io_debugEnqLsq_needAlloc_3 = vif.io_debugEnqLsq_needAlloc_3;
tr.io_debugEnqLsq_needAlloc_4 = vif.io_debugEnqLsq_needAlloc_4;
tr.io_debugEnqLsq_needAlloc_5 = vif.io_debugEnqLsq_needAlloc_5;
tr.io_debugEnqLsq_req_0_valid = vif.io_debugEnqLsq_req_0_valid;
tr.io_debugEnqLsq_req_0_bits_robIdx_value = vif.io_debugEnqLsq_req_0_bits_robIdx_value;
tr.io_debugEnqLsq_req_0_bits_lqIdx_value = vif.io_debugEnqLsq_req_0_bits_lqIdx_value;
tr.io_debugEnqLsq_req_1_valid = vif.io_debugEnqLsq_req_1_valid;
tr.io_debugEnqLsq_req_1_bits_robIdx_value = vif.io_debugEnqLsq_req_1_bits_robIdx_value;
tr.io_debugEnqLsq_req_1_bits_lqIdx_value = vif.io_debugEnqLsq_req_1_bits_lqIdx_value;
tr.io_debugEnqLsq_req_2_valid = vif.io_debugEnqLsq_req_2_valid;
tr.io_debugEnqLsq_req_2_bits_robIdx_value = vif.io_debugEnqLsq_req_2_bits_robIdx_value;
tr.io_debugEnqLsq_req_2_bits_lqIdx_value = vif.io_debugEnqLsq_req_2_bits_lqIdx_value;
tr.io_debugEnqLsq_req_3_valid = vif.io_debugEnqLsq_req_3_valid;
tr.io_debugEnqLsq_req_3_bits_robIdx_value = vif.io_debugEnqLsq_req_3_bits_robIdx_value;
tr.io_debugEnqLsq_req_3_bits_lqIdx_value = vif.io_debugEnqLsq_req_3_bits_lqIdx_value;
tr.io_debugEnqLsq_req_4_valid = vif.io_debugEnqLsq_req_4_valid;
tr.io_debugEnqLsq_req_4_bits_robIdx_value = vif.io_debugEnqLsq_req_4_bits_robIdx_value;
tr.io_debugEnqLsq_req_4_bits_lqIdx_value = vif.io_debugEnqLsq_req_4_bits_lqIdx_value;
tr.io_debugEnqLsq_req_5_valid = vif.io_debugEnqLsq_req_5_valid;
tr.io_debugEnqLsq_req_5_bits_robIdx_value = vif.io_debugEnqLsq_req_5_bits_robIdx_value;
tr.io_debugEnqLsq_req_5_bits_lqIdx_value = vif.io_debugEnqLsq_req_5_bits_lqIdx_value;
tr.io_debugInstrAddrTransType_bare = vif.io_debugInstrAddrTransType_bare;
tr.io_debugInstrAddrTransType_sv39 = vif.io_debugInstrAddrTransType_sv39;
tr.io_debugInstrAddrTransType_sv39x4 = vif.io_debugInstrAddrTransType_sv39x4;
tr.io_debugInstrAddrTransType_sv48 = vif.io_debugInstrAddrTransType_sv48;
tr.io_debugInstrAddrTransType_sv48x4 = vif.io_debugInstrAddrTransType_sv48x4;
tr.io_storeDebugInfo_0_robidx_value = vif.io_storeDebugInfo_0_robidx_value;
tr.io_storeDebugInfo_1_robidx_value = vif.io_storeDebugInfo_1_robidx_value;
tr.compare = vif.compare;
tr.CSR_in_agent_xaction = vif.CSR_in_agent_xaction;
tr.super_result = vif.super_result;
<<<<<<< HEAD

=======
>>>>>>> feat_uvm
            // Send sampled transaction back to Python
            sequence_send(tr);
            prev_tr.copy(tr);

            `uvm_info("CSR_in_agent_xaction_monitor",
                      $sformatf("Sampled DUT signals and sent to Python:\n%s", tr.sprint()),
                      UVM_MEDIUM)
        end
    endtask
endclass

// =============================================================================
// Environment
// =============================================================================

class example_env extends uvm_env;
    `uvm_component_utils(example_env)

CSR_in_agent_xaction_xagent            CSR_in_agent_xaction_agent;
    CSR_in_agent_xaction_xagent_config     CSR_in_agent_xaction_config;
CSR_in_agent_xaction_driver            CSR_in_agent_xaction_drv;
    CSR_in_agent_xaction_monitor           CSR_in_agent_xaction_mon;
virtual dut_interface vif;
<<<<<<< HEAD

=======
>>>>>>> feat_uvm
    function new (string name = "example_env", uvm_component parent = null);
        super.new(name, parent);

        // Configure agents with factory overrides
CSR_in_agent_xaction_config = new("CSR_in_agent_xaction_config");
        CSR_in_agent_xaction_config.is_active = UVM_ACTIVE;
        uvm_config_db#(CSR_in_agent_xaction_xagent_config)::set(this, "CSR_in_agent_xaction_agent", "CSR_in_agent_xaction_xagent_config", CSR_in_agent_xaction_config);

        // Override default driver with custom implementation
        set_type_override_by_type(CSR_in_agent_xaction_xdriver::get_type(), CSR_in_agent_xaction_driver::get_type());
<<<<<<< HEAD
=======

>>>>>>> feat_uvm
        // Override default monitor with custom implementation
        set_type_override_by_type(CSR_in_agent_xaction_xmonitor::get_type(), CSR_in_agent_xaction_monitor::get_type());
endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        // Build agents
CSR_in_agent_xaction_agent = CSR_in_agent_xaction_xagent::type_id::create("CSR_in_agent_xaction_agent", this);
<<<<<<< HEAD

=======
>>>>>>> feat_uvm
        // Get virtual interface
if(!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("example_env", "Virtual interface must be set for vif")
endfunction

    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
endfunction

    virtual task main_phase(uvm_phase phase);
        phase.raise_objection(this);
        // Wait for Python to send transactions
        // Python controls simulation time via Step() calls
        #100000;
        phase.drop_objection(this);
    endtask

endclass

// =============================================================================
// Test
// =============================================================================

class example_test extends uvm_test;
    `uvm_component_utils(example_test)
    example_env env;

    function new (string name = "example_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = example_env::type_id::create("example_env", this);
    endfunction

    virtual task main_phase(uvm_phase phase);
        phase.raise_objection(this);
`uvm_info("example_test", "UVM test started with DUT, waiting for Python to drive transactions...", UVM_LOW);
#100000;
        phase.drop_objection(this);
    endtask
endclass

// =============================================================================
// Top Module
// =============================================================================

module sv_main;
    logic clk;
    logic rst_n;

// DUT mode: create DUT interface
    dut_interface dif(clk, rst_n);

// TODO: Instantiate your DUT module here and connect to dif interface
    // Example:
    // YourDUT dut (
    //     .clk(clk),
    //     .rst_n(rst_n),
    //     .a(dif.a),
    //     .b(dif.b)
    //     // ... connect all signals from dut_interface
    // );
// Clock generation
    initial begin
        clk = 0;
        forever #2 clk = ~clk;
    end

    // Reset generation
    initial begin
        rst_n = 1'b0;
        #10 rst_n = 1'b1;
    end

    initial begin
        // Set virtual interface in config_db
uvm_config_db#(virtual dut_interface)::set(null, "*", "vif", dif);
// Run test
        run_test("example_test");
    end
endmodule
