# File       : CSR_in_agent_xaction_xagent.py
# Author     : automatically generated by picker
# Date       : 2026-02-03 12:11:13
# Description: Unified agent for UVM-Python communication
# Version    : v0.1

from typing import Optional, Callable, Dict, Type, List, NamedTuple


class FieldMeta(NamedTuple):
    """Metadata for a transaction field."""
    name: str
    byte_offset: int
    byte_count: int
    bit_count: int

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
except ImportError:
    import tlm_pbsb as u
    import xspcomm as xsp


class BaseTransaction:
    """Base class for UVM transactions with common serialization logic."""

    _fields_metadata: List[FieldMeta] = []
    _byte_stream_count: int = 0
    _transaction_type: str = "BaseTransaction"

    def __init__(self, msg: Optional[bytes] = None) -> None:
        self._init_fields()
        if msg is not None:
            self.from_msg(msg)

    def _init_fields(self) -> None:
        raise NotImplementedError(f"{self.__class__.__name__} must implement _init_fields()")

    # ============================================================================
    # Serialization/Deserialization Core Methods
    # ============================================================================

    @staticmethod
    def _serialize_field(value: int, byte_count: int) -> bytes:
        """
        Serialize a single field to bytes.

        Args:
            value: Integer value to serialize
            byte_count: Number of bytes for this field

        Returns:
            Serialized bytes in big-endian format
        """
        if byte_count == 1:
            return bytes([value & 0xFF])
        return value.to_bytes(byte_count, byteorder='big')

    @staticmethod
    def _deserialize_field(data: bytes, offset: int, byte_count: int) -> int:
        """
        Deserialize a single field from bytes.

        Args:
            data: Byte array containing serialized data
            offset: Starting position in the byte array
            byte_count: Number of bytes for this field

        Returns:
            Deserialized integer value
        """
        if byte_count == 1:
            return data[offset]
        return int.from_bytes(data[offset:offset + byte_count], byteorder='big')

    def from_msg(self, msg: bytes) -> None:
        """Deserialize from UVM message."""
        if len(msg) < self._byte_stream_count:
            raise ValueError(
                f"Invalid message length for {self._transaction_type}: "
                f"expected {self._byte_stream_count} bytes, got {len(msg)} bytes"
            )

        for field in self._fields_metadata:
            field_value = self._deserialize_field(msg, field.byte_offset, field.byte_count)
            getattr(self, field.name).value = field_value

    def to_bytes(self) -> bytes:
        """Serialize to byte stream."""
        result = bytearray(self._byte_stream_count)

        for field in self._fields_metadata:
            value = getattr(self, field.name).value
            field_bytes = self._serialize_field(value, field.byte_count)
            result[field.byte_offset:field.byte_offset + field.byte_count] = field_bytes

        return bytes(result)

    def copy_from_dict(self, values: Dict[str, int]) -> None:
        """
        Copy values from a dictionary to transaction fields.

        Args:
            values: Dictionary mapping field names to values

        Example:
            tr.copy_from_dict({'a': 10, 'b': 20})
        """
        for field in self._fields_metadata:
            if field.name in values:
                getattr(self, field.name).value = values[field.name]

    def to_dict(self) -> Dict[str, int]:
        """
        Export transaction fields as a dictionary.

        Returns:
            Dictionary mapping field names to values
        """
        return {field.name: getattr(self, field.name).value for field in self._fields_metadata}

    def __repr__(self) -> str:
        fields = ', '.join([f"{field.name}={getattr(self, field.name).value}" for field in self._fields_metadata])
        return f"{self._transaction_type}({fields})"


class CSR_in_agent_xaction(BaseTransaction):
    """CSR_in_agent_xaction transaction (58 bytes)"""

    _transaction_type = "CSR_in_agent_xaction"
    _byte_stream_count = 58
    _fields_metadata = [
        FieldMeta("io_csr_intrBitSet", 0, 1, 1),
        FieldMeta("io_csr_wfiEvent", 1, 1, 1),
        FieldMeta("io_csr_criticalErrorState", 2, 1, 1),
        FieldMeta("io_snpt_snptDeq", 3, 1, 1),
        FieldMeta("io_snpt_useSnpt", 4, 1, 1),
        FieldMeta("io_snpt_snptSelect", 5, 1, 2),
        FieldMeta("io_snpt_flushVec_0", 6, 1, 1),
        FieldMeta("io_snpt_flushVec_1", 7, 1, 1),
        FieldMeta("io_snpt_flushVec_2", 8, 1, 1),
        FieldMeta("io_snpt_flushVec_3", 9, 1, 1),
        FieldMeta("io_wfi_safeFromMem", 10, 1, 1),
        FieldMeta("io_wfi_safeFromFrontend", 11, 1, 1),
        FieldMeta("io_wfi_enable", 12, 1, 1),
        FieldMeta("io_fromVecExcpMod_busy", 13, 1, 1),
        FieldMeta("io_readGPAMemData_gpaddr", 14, 7, 56),
        FieldMeta("io_readGPAMemData_isForVSnonLeafPTE", 21, 1, 1),
        FieldMeta("io_vstartIsZero", 22, 1, 1),
        FieldMeta("io_debugEnqLsq_canAccept", 23, 1, 1),
        FieldMeta("io_debugEnqLsq_needAlloc_0", 24, 1, 2),
        FieldMeta("io_debugEnqLsq_needAlloc_1", 25, 1, 2),
        FieldMeta("io_debugEnqLsq_needAlloc_2", 26, 1, 2),
        FieldMeta("io_debugEnqLsq_needAlloc_3", 27, 1, 2),
        FieldMeta("io_debugEnqLsq_needAlloc_4", 28, 1, 2),
        FieldMeta("io_debugEnqLsq_needAlloc_5", 29, 1, 2),
        FieldMeta("io_debugEnqLsq_req_0_valid", 30, 1, 1),
        FieldMeta("io_debugEnqLsq_req_0_bits_robIdx_value", 31, 1, 8),
        FieldMeta("io_debugEnqLsq_req_0_bits_lqIdx_value", 32, 1, 7),
        FieldMeta("io_debugEnqLsq_req_1_valid", 33, 1, 1),
        FieldMeta("io_debugEnqLsq_req_1_bits_robIdx_value", 34, 1, 8),
        FieldMeta("io_debugEnqLsq_req_1_bits_lqIdx_value", 35, 1, 7),
        FieldMeta("io_debugEnqLsq_req_2_valid", 36, 1, 1),
        FieldMeta("io_debugEnqLsq_req_2_bits_robIdx_value", 37, 1, 8),
        FieldMeta("io_debugEnqLsq_req_2_bits_lqIdx_value", 38, 1, 7),
        FieldMeta("io_debugEnqLsq_req_3_valid", 39, 1, 1),
        FieldMeta("io_debugEnqLsq_req_3_bits_robIdx_value", 40, 1, 8),
        FieldMeta("io_debugEnqLsq_req_3_bits_lqIdx_value", 41, 1, 7),
        FieldMeta("io_debugEnqLsq_req_4_valid", 42, 1, 1),
        FieldMeta("io_debugEnqLsq_req_4_bits_robIdx_value", 43, 1, 8),
        FieldMeta("io_debugEnqLsq_req_4_bits_lqIdx_value", 44, 1, 7),
        FieldMeta("io_debugEnqLsq_req_5_valid", 45, 1, 1),
        FieldMeta("io_debugEnqLsq_req_5_bits_robIdx_value", 46, 1, 8),
        FieldMeta("io_debugEnqLsq_req_5_bits_lqIdx_value", 47, 1, 7),
        FieldMeta("io_debugInstrAddrTransType_bare", 48, 1, 1),
        FieldMeta("io_debugInstrAddrTransType_sv39", 49, 1, 1),
        FieldMeta("io_debugInstrAddrTransType_sv39x4", 50, 1, 1),
        FieldMeta("io_debugInstrAddrTransType_sv48", 51, 1, 1),
        FieldMeta("io_debugInstrAddrTransType_sv48x4", 52, 1, 1),
        FieldMeta("io_storeDebugInfo_0_robidx_value", 53, 1, 8),
        FieldMeta("io_storeDebugInfo_1_robidx_value", 54, 1, 8),
        FieldMeta("compare", 55, 1, 1),
        FieldMeta("CSR_in_agent_xaction", 56, 1, 1),
        FieldMeta("super_result", 57, 1, 1),
        ]

    def _init_fields(self) -> None:
        
        self.io_csr_intrBitSet = xsp.XData(1)
        
        self.io_csr_wfiEvent = xsp.XData(1)
        
        self.io_csr_criticalErrorState = xsp.XData(1)
        
        self.io_snpt_snptDeq = xsp.XData(1)
        
        self.io_snpt_useSnpt = xsp.XData(1)
        
        self.io_snpt_snptSelect = xsp.XData(2)
        
        self.io_snpt_flushVec_0 = xsp.XData(1)
        
        self.io_snpt_flushVec_1 = xsp.XData(1)
        
        self.io_snpt_flushVec_2 = xsp.XData(1)
        
        self.io_snpt_flushVec_3 = xsp.XData(1)
        
        self.io_wfi_safeFromMem = xsp.XData(1)
        
        self.io_wfi_safeFromFrontend = xsp.XData(1)
        
        self.io_wfi_enable = xsp.XData(1)
        
        self.io_fromVecExcpMod_busy = xsp.XData(1)
        
        self.io_readGPAMemData_gpaddr = xsp.XData(56)
        
        self.io_readGPAMemData_isForVSnonLeafPTE = xsp.XData(1)
        
        self.io_vstartIsZero = xsp.XData(1)
        
        self.io_debugEnqLsq_canAccept = xsp.XData(1)
        
        self.io_debugEnqLsq_needAlloc_0 = xsp.XData(2)
        
        self.io_debugEnqLsq_needAlloc_1 = xsp.XData(2)
        
        self.io_debugEnqLsq_needAlloc_2 = xsp.XData(2)
        
        self.io_debugEnqLsq_needAlloc_3 = xsp.XData(2)
        
        self.io_debugEnqLsq_needAlloc_4 = xsp.XData(2)
        
        self.io_debugEnqLsq_needAlloc_5 = xsp.XData(2)
        
        self.io_debugEnqLsq_req_0_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_0_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_0_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugEnqLsq_req_1_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_1_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_1_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugEnqLsq_req_2_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_2_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_2_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugEnqLsq_req_3_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_3_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_3_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugEnqLsq_req_4_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_4_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_4_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugEnqLsq_req_5_valid = xsp.XData(1)
        
        self.io_debugEnqLsq_req_5_bits_robIdx_value = xsp.XData(8)
        
        self.io_debugEnqLsq_req_5_bits_lqIdx_value = xsp.XData(7)
        
        self.io_debugInstrAddrTransType_bare = xsp.XData(1)
        
        self.io_debugInstrAddrTransType_sv39 = xsp.XData(1)
        
        self.io_debugInstrAddrTransType_sv39x4 = xsp.XData(1)
        
        self.io_debugInstrAddrTransType_sv48 = xsp.XData(1)
        
        self.io_debugInstrAddrTransType_sv48x4 = xsp.XData(1)
        
        self.io_storeDebugInfo_0_robidx_value = xsp.XData(8)
        
        self.io_storeDebugInfo_1_robidx_value = xsp.XData(8)
        
        self.compare = xsp.XData(1)
        
        self.CSR_in_agent_xaction = xsp.XData(1)
        
        self.super_result = xsp.XData(1)
        



class Agent:
    """Unified agent managing transaction types and TLM communication."""

    _vcs_initialized = False

    def __init__(self, monitor_callback: Optional[Callable[[str, BaseTransaction], None]] = None, auto_register: bool = True) -> None:
        if not Agent._vcs_initialized:
            u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
            Agent._vcs_initialized = True
        self._send_ports: Dict[str, any] = {}
        self._receive_ports: Dict[str, any] = {}
        self._transaction_registry: Dict[str, Type[BaseTransaction]] = {}
        self._monitor_callback = monitor_callback

        # Clock management
        self._clock_enabled: bool = False
        self._cycle_count: int = 0
        self._posedge_callbacks: List[Callable[[int], None]] = []
        self._negedge_callbacks: List[Callable[[int], None]] = []

        # Auto-register all transaction types with default ports
        if auto_register:
            self.register_transaction(CSR_in_agent_xaction, send_port="CSR_in_agent_xaction", receive_port="CSR_in_agent_xaction")
            

    def register_transaction(self, trans_class: Type[BaseTransaction],
                            send_port: Optional[str] = None,
                            receive_port: Optional[str] = None) -> None:
        """Register transaction type with communication ports."""
        trans_type = trans_class._transaction_type
        self._transaction_registry[trans_type] = trans_class

        if send_port:
            port = u.TLMPub(send_port)
            port.Connect()
            self._send_ports[trans_type] = port

        if receive_port:
            if not self._monitor_callback:
                print(f"Warning: receive_port '{receive_port}' specified but no monitor_callback provided.")
            else:
                def make_callback(t_type, t_class):
                    return lambda msg: self._monitor_callback(t_type, t_class(msg.as_bytes()))

                port = u.TLMSub(receive_port, make_callback(trans_type, trans_class))
                port.Connect()
                self._receive_ports[trans_type] = port

    def drive(self, transaction: BaseTransaction) -> None:
        """Drive transaction to UVM with automatic port routing."""
        trans_type = transaction._transaction_type

        if trans_type not in self._send_ports:
            raise ValueError(f"No send port for '{trans_type}'. Call register_transaction() first.")

        byte_stream = transaction.to_bytes()
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        self._send_ports[trans_type].SendMsg(uvm_message)

    def run(self, cycles: int, count_cycles: bool = True) -> None:
        """
        Drive UVM clock cycles and execute callbacks if clock is enabled.

        Args:
            cycles: Number of UVM steps to execute
            count_cycles: Whether to increment cycle counter (default: True)
        """
        for _ in range(cycles):
            u.step(1)
            if self._clock_enabled and count_cycles:
                self._cycle_count += 1
                # Execute posedge callbacks
                for callback in self._posedge_callbacks:
                    callback(self._cycle_count)

    def InitClock(self, domain: str = "default", frequency: Optional[float] = None) -> None:
        """
        Initialize clock tracking and enable callbacks.

        Args:
            domain: Clock domain name for documentation (default: "default")
            frequency: Optional clock frequency in Hz

        Example:
            agent.InitClock()
            agent.InitClock(domain="sys_clk", frequency=100e6)
        """
        self._clock_enabled = True
        self._cycle_count = 0
        freq_info = f", frequency: {frequency/1e6:.2f} MHz" if frequency else ""
        print(f"[Agent.InitClock] Clock tracking initialized (domain: {domain}{freq_info})")

    def StepRis(self, callback: Callable[[int], None]) -> None:
        """
        Register callback for clock rising edge.

        Args:
            callback: Function that takes cycle number as argument

        Example:
            def on_posedge(cycle):
                print(f"Cycle {cycle}")

            agent.StepRis(on_posedge)
        """
        self._posedge_callbacks.append(callback)

    def StepFal(self, callback: Callable[[int], None]) -> None:
        """
        Register callback for clock falling edge.

        Args:
            callback: Function that takes cycle number as argument

        Note: Currently falling edge callbacks are not triggered in Pack mode.
        """
        self._negedge_callbacks.append(callback)
        print("[Agent.StepFal] Warning: Falling edge callbacks are not supported in Pack mode")

    def GetCycleCount(self) -> int:
        """
        Get current simulation cycle count.

        Returns:
            Number of cycles executed since InitClock
        """
        return self._cycle_count
